defmodule PPM do

  # write(Name, Image) The image is a list of rows, each row a list of
  # tuples {R,G,B} where the values are flots from 0 to 1. The image
  # is written using PMM format P6 and color depth 0-255. This means that
  # each tuple is written as three bytes.

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn r ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end

  defp row(row) do
    List.foldr(row, [], fn({r, g, b}, a) ->
      [trunc(r * 255), trunc(g * 255), trunc(b * 255) | a]
    end)
  end

end

defmodule Tracer do

  @black {0, 0, 0}
  @white {1, 1, 1}


  def tracer(camera, objects) do
    {w, h} = camera.size
    for y <- 1..h, do: for(x <- 1..w, do: trace(x, y, camera, objects))
  end

  def trace(x, y, camera, objects) do
    ray = Camera.ray(camera, x, y)
    trace(ray, objects)
  end

  def trace(ray, objects) do
    case intersect(ray, objects) do
      {:inf, _} ->
        @black

      {_, _} ->
        @white
    end
  end

  def intersect(ray, objects) do
    List.foldl(objects, {:inf, nil}, fn (object, sofar) ->
      {dist, _} = sofar

      case Object.intersect(object, ray) do
        {:ok, d} when d < dist ->
          {d, object}
        _ ->
          sofar
      end
    end)
  end

end

defmodule Vector do

  # Scalar multiplication.
  def smul({x1, x2, x3}, s) do
    {x1 * s, x2 * s, x3 * s}
  end

  # Addition and subtarction.
  def sub({x1, x2, x3}, {y1, y2, y3}) do
    {x1 - y1, x2 - y2, x3 - y3}
  end

  def add({x1, x2, x3}, {y1, y2, y3}) do
    {x1 + y1, x2 + y2, x3 + y3}
  end

  # Dot product.
  def dot({x1, x2, x3}, {y1, y2, y3}) do
    x1 * y1 + x2 * y2 + x3 * y3
  end

  # Scaling a vector to a specified length.
  def scale(x, l) do
    n = norm(x)
    # this will crash if N == 0!
    smul(x, l / n)
  end

  # Normalize by scaling to norm 1.
  def normalize(x) do
    scale(x, 1)
  end

  # Square of a vector.
  def sq(x) do
    dot(x, x)
  end

  # The norm (length) of a vector.
  def norm({x1, x2, x3}) do
    :math.sqrt(x1 * x1 + x2 * x2 + x3 * x3)
  end

  # Cross product, used to find a vector that as ortogonal to
  # both x and y.
  def cross({x1, x2, x3}, {y1, y2, y3}) do
    {x2 * y3 - x3 * y2, x3 * y1 - x1 * y3, x1 * y2 - x2 * y1}
  end

end

defmodule Ray do

  defstruct(pos: {0,0,0}, dir: {0,0,1})

end

defprotocol Object do

  def intersect(object, ray)

  def normal(object, ray, pos)

end

defmodule Sphere do

  @color {1.0, 0.4, 0.4}
  @brilliance 0
  @transparency 0
  @refraction 1.5

  defstruct(
    radius: 2,
    pos: {0, 0, 0},
    color: @color,
    brilliance: @brilliance,
    transparency: @transparency,
    refraction: @refraction
  )


  defimpl Object do

    def intersect(sphere, ray) do
      Sphere.intersect(sphere, ray)
    end

    def normal(sphere, _, pos) do
      # assuming we always hit it from the outside
      Vector.normalize(Vector.sub(pos, sphere.pos))
    end

  end

  def intersect(%Sphere{pos: spos, radius: radius},  %Ray{pos: rpos, dir: dir}) do
    k = Vector.sub(spos, rpos)
    a = Vector.dot(dir, k)
    a2 = :math.pow(a, 2)
    k2 = :math.pow(Vector.norm(k), 2)
    r2 = :math.pow(radius, 2)
    t2 = a2 - k2 + r2
    closest(t2, a)
  end

  defp closest(t2, a) do
    if t2 < 0 do
      :no
    else
      t = :math.sqrt(t2)
      d1 = a - t
      d2 = a + t

      cond do
        d1 > 0.0 and d2 > 0.0 ->
          {:ok, min(d1, d2)}
        d1 > 0.0 ->
          {:ok, d1}
        d2 > 0.0 ->
          {:ok, d2}
        true ->
          :no
      end
    end
  end





end

defmodule Camera do

  defstruct(
    pos: nil,
    corner: nil,
    right: nil,
    down: nil,
    size: nil
  )

  def normal(size) do
    {width, height} = size
    d = width * 1.2
    h = width / 2
    v = height / 2
    pos = {0,0,0}
    corner = {-h, v, d}
    right = {1, 0, 0}
    down = {0, -1, 0}
    %Camera{pos: pos, corner: corner, right: right, down: down, size: size}
  end


  def ray(%Camera{pos: pos, right: right, down: down, corner: corner}, x, y) do
    x_pos = Vector.smul(right, x)
    y_pos = Vector.smul(down, y)
    pixle = Vector.add(corner, Vector.add(x_pos, y_pos))
    dir = Vector.normalize(pixle)
    %Ray{pos: pos, dir: dir}
  end

end

defmodule Test do

  def snap do
    camera = Camera.normal({800, 600})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}}

    image = Tracer.tracer(camera, [obj1, obj2, obj3])
    PPM.write("test.ppm", image)
  end

end

defmodule Light do

  @white {1.0, 1.0, 1.0}

  defstruct(
    pos: nil,
    color: @white
  )

  def illuminate(obj, ill, world) do
    color = obj.color
    ill(color, mul(ill, world.ambient))
  end

  def illuminate(obj, refl, ill, world) do
    surface = ill(obj.color, mul(ill, world.ambient))
    mul(surface, mod(refl, obj.brilliance))
  end

  def illuminate(obj, refl, refr, ill, world) do
    surface = ill(obj.color, mul(ill, world.ambient))
    mul(add(surface, refr, obj.transparency), mod(refl, obj.brilliance))
  end

  def combine(point, normal, lights) do
    List.foldl(lights, {0, 0, 0},
      fn(light, contr) ->
         mul(contribute(point, normal, light.pos, light.color), contr)
      end)
  end

  def contribute(point, normal, source, {r, g, b}) do
    direction = Vector.normalize(Vector.sub(source, point))
    cos = Vector.dot(direction, normal)
    {r * cos, g * cos, b * cos}
  end


  ## How to work with colors

  ## combine the two lights
  def mul({r1, g1, b1}, {r2, g2, b2}) do
    {1 - (1 - r1) * (1 - r2), 1 - (1 - g1) * (1 - g2), 1 - (1 - b1) * (1 - b2)}
  end

  ## illuminate a surface of a given color
  def ill({r1, g1, b1}, {r2, g2, b2}) do
    {r1 * r2, g1 * g2, b1 * b2}
  end

  ## reduce a light
  def mod({r1, g1, b1}, t) do
    {r1 * t, g1 * t, b1 * t}
  end

  ## combine two colors given a ratio
  def add({r1, g1, b1}, {r2, g2, b2}, t) do
    s = 1 - t
    {r1 * s + r2 * t, g1 * s + g2 * t, b1 * s + b2 * t}
  end

end

defmodule World do

  @background {0, 0, 0}
  @depth 2
  @ambient {0.3, 0.3, 0.3}
  @refraction 1

  defstruct(
    objects: [],
    lights: [],
    background: @background,
    depth: @depth,
    ambient: @ambient,
    refraction: @refraction
  )

end

defmodule Plane do

  @color {1.0, 0.4, 0.4}
  @brilliance 0
  @transparency 0
  @refraction 1.5


  defstruct(
    pos0: {0, 0, 0},
    pos1: {1, 0, 0},
    pos2: {0, 1, 0},
    color: @color,
    brilliance: @brilliance,
    transparency: @transparency,
    refraction: @refraction
  )


  defimpl Object do

    def intersect(plane, ray) do
      Plane.intersect(plane, ray)
    end

    def normal(plane, ray, _pos) do
      #  this is not correct, we need to know from which way we're looking
      dir01 = Vector.sub(plane.pos1, plane.pos0)
      dir02 = Vector.sub(plane.pos2, plane.pos0)
      norm1 = Vector.normalize(Vector.cross(dir01, dir02))
      norm2 = Vector.normalize(Vector.cross(dir02, dir01))
      if Vector.norm(Vector.add(ray.dir,norm1)) < Vector.norm(Vector.add(ray.dir,norm2)) do
	norm1
      else
	norm2
      end
    end

  end

  def intersect(plane, ray) do

    p0 = plane.pos0
    p1 = plane.pos1
    p2 = plane.pos2

    p01 = Vector.sub(p1,p0)
    p02 = Vector.sub(p2,p0)

    pos = ray.pos

    dir = ray.dir

    neg = Vector.smul(dir, -1)

    det = Vector.dot(neg, Vector.cross(p01, p02))

    org = Vector.sub(pos,p0)

    if det != 0 do
      t = Vector.dot(Vector.cross(p01, p02), org) / det
      #IO.write("t =  #{t} \n")
      if t > 0 do
	u = Vector.dot(Vector.cross(p02, neg), org) / det
	v = Vector.dot(Vector.cross(neg, p01), org) / det

	#IO.write("u =  #{u} \n")
	#IO.write("v =  #{v} \n")
	if 0 < u and u < 1 and 0 < v and v < 1  and (u + v) <= 1  do
	  # we have an intersection
	  {:ok, t }
	else
	  :no
	end
      else
	# behind the camera
	:no
      end
    else
      # parallel or in plane
      :no
    end
  end





end

defmodule Snap do

  def snap(0) do
    camera = Camera.normal({800, 600})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}}

    image = Tracer.tracer(camera, [obj1, obj2, obj3])
    PPM.write("snap0.ppm", image)
  end

  def snap(1) do
    camera = Camera.normal({800, 600})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}, color: {1, 0.5, 0}}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color:  {0, 0.8, 0.2}}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1}}

    image = TracerColor.tracer(camera, [obj1, obj2, obj3])
    PPM.write("snap1.ppm", image)
  end

  def snap(2) do
    camera = Camera.normal({1920, 1080})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}, color: {1, 0.5, 0}}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color: {0, 0.8, 0.2}}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1}}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.6, 0.6, 0.6}}
    image = TracerLight.tracer(camera, world)
    PPM.write("snap2.ppm", image)
  end

  def snap(3) do
    camera = Camera.normal({1920, 1080})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}, color: {1, 0.5, 0}, brilliance: 1.0}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color: {0, 0.8, 0.2}, brilliance: 0.4}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1}, brilliance: 0.8}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.1, 0.1, 0.1}
    }

    image = TracerReflection.tracer(camera, world)
    PPM.write("snap3.ppm", image)
  end

  def snap(4) do
    camera = Camera.normal({1920, 1080})

    obj1 = %Sphere{radius: 140, pos: {  0, 0, 700}, color: {1, 1, 1}, brilliance: 0.4}
    obj2 = %Sphere{radius:  50, pos: {200, 0, 600}, color: {1, 1, 1}, brilliance: 0.8}
    obj3 = %Sphere{radius:  50, pos: {-80, 0, 400}, color: {1, 1, 1}, brilliance: 0.5}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.1, 0.1, 0.1},
      depth: 3
    }

    image = TracerReflection.tracer(camera, world)
    PPM.write("snap4.ppm", image)
  end

  def snap(5) do
    camera = Camera.normal({3200, 1800})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}, color: {1.0, 0.5, 0}, brilliance: 0.4}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color: {0, 0.8, 0.2}, brilliance: 0.4}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1.0}, brilliance: 0.8}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.1, 0.1, 0.1},
      depth: 3
    }

    image = TracerReflection.tracer(camera, world)
    PPM.write("snap5.ppm", image)
  end

  def snap(6) do
    camera = Camera.normal({1920, 1080})

    obj1 = %Sphere{radius: 140, pos: {0, 0, 700}, color: {1.0, 0.5, 0}, brilliance: 1}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color: {0, 0.8, 0.2}, brilliance: 1}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1.0}, brilliance: 1}

    obj4 = %Plane{pos0: {-20, -20, 500}, pos1: {20,-20,550}, pos2: {0,30,600}, color: {0, 0.2, 0.4}, brilliance: 1}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3, obj4],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.1, 0.1, 0.1},
      depth: 3
    }

    image = TracerReflection.tracer(camera, world)
    PPM.write("snap6.ppm", image)
  end

  def snap(7) do
    camera = Camera.normal({1920, 1080})

    obj1 = %Sphere{radius: 140, pos: {-50, 0, 700}, color: {1.0, 0.5, 0}, brilliance: 1}
    obj2 = %Sphere{radius: 50, pos: {200, 0, 600}, color: {0, 0.8, 0.2}, brilliance: 1}
    obj3 = %Sphere{radius: 50, pos: {-80, 0, 400}, color: {0.1, 0.1, 1.0}, brilliance: 1}

    obj4 = %Plane{pos0: {-20, -20, 500}, pos1: {20,-20,550}, pos2: {0,30,600}, color: {0, 0.8,0}, brilliance: 1}

    obj5 = %Plane{pos0: {-50, -200, 900}, pos1: {500,-240,800}, pos2: {200,300,850}, color: {0.1, 0.1, 0.1}, brilliance: 1}

    light1 = %Light{pos: {-1000, 1000, 700}, color: {1.0, 0.3, 0.3}}
    light2 = %Light{pos: {800, 800, 0}, color: {0.3, 1.0, 0.3}}
    light3 = %Light{pos: {800, -800, 0}, color: {0.3, 0.3, 1.0}}

    world = %World{
      objects: [obj1, obj2, obj3, obj4, obj5],
      lights: [light1, light2, light3],
      background: {0.0, 0.0, 0.0},
      ambient: {0.1, 0.1, 0.1},
      depth: 3
    }

    image = TracerReflection.tracer(camera, world)
    PPM.write("snap7.ppm", image)
  end




end
